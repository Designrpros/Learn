"use client";

import { useGenerationStore } from "@/lib/generation-store";
import { useEffect, useState, useRef } from "react";
import ReactMarkdown from "react-markdown"; // Verify if used?
import { WikiLink } from "./wiki-link";

import { Loader2, Sparkles } from "lucide-react";
import { cn } from "@/lib/utils";

interface WikiContentMonitorProps {
    topic: any;
    initialContent: string;
}

import { useRouter } from "next/navigation";

// ... inside component function ...
export function WikiContentMonitor({ topic, initialContent }: WikiContentMonitorProps) {
    const router = useRouter();
    const { activeJob, startJob, queue } = useGenerationStore();
    const [localContent, setLocalContent] = useState(initialContent);
    const [isGenerating, setIsGenerating] = useState(false);
    const [wasGenerating, setWasGenerating] = useState(false);

    // Is THIS topic currently being generated?
    const isJobForThisTopic = activeJob?.topicId === topic.id;
    const isThisTopicGenerating = isJobForThisTopic && activeJob?.status === 'generating';

    // Monitor active state to trigger refresh on completion
    useEffect(() => {
        if (isThisTopicGenerating) {
            setWasGenerating(true);
        } else if (wasGenerating && activeJob?.status === 'completed') {
            // Job just finished successfully
            setWasGenerating(false);
            console.log("Generation finished, refreshing page data...");
            router.refresh();
        }
    }, [isThisTopicGenerating, wasGenerating, activeJob?.status, router]);

    // Determine content to show:
    // If we have an active job (generating OR completed) use that content to avoid flicker before refresh
    const displayContent = (isJobForThisTopic && activeJob?.content)
        ? activeJob.content
        : (localContent || initialContent);


    useEffect(() => {
        // Just sync initial if needed? No, purely derived.
    }, []);

    const handleAutoGenerate = () => {
        if (!isGenerating && (!initialContent || initialContent === "Autogenerated stub.")) {
            startJob({
                topicId: topic.id,
                type: 'syllabus',
            });
        }
    };

    // Auto-trigger if empty stub
    const [hasAttemptedAuto, setHasAttemptedAuto] = useState(false);
    const initiatedRef = useRef(false);

    useEffect(() => {
        // Only run if it's a stub
        if (!initialContent || initialContent === "Autogenerated stub.") {
            // Prevent multiple triggers
            if (changeTrackerRef.current) return;

            // If already active globally, don't auto-trigger (we will listen to it)
            // We check this via a ref or by trusting the initial prop, but we can't access store state in a [] effect easily without refs if it changes.
            // However, for "On Load", we just care about the initial state.

            initiatedRef.current = true;

            const timer = setTimeout(() => {
                // Check store state via the closure? No, closure might be stale.
                // We trust the component re-render to handle "Already Active".
                // Here we just fire the intention.
                // BUT we need to check if it's ALREADY active now.
                // We'll rely on the `hasAttemptedAuto` state transition to show the button if it didn't start.

                // We call the function. If it's already running, the store prevents dups (mostly).
                // We can't easily check 'activeJob' status inside this stale closure without a ref to the store.
                // But `startJob` is stable.

                // Let's just fire it.
                console.log("Auto-triggering generation for stub...");
                // Verify one last time via a helper or just fire.
                startJob({
                    topicId: topic.id,
                    type: 'syllabus',
                });
                setHasAttemptedAuto(true);
            }, 1000);

            return () => clearTimeout(timer);
        }
    }, []); // Run ONCE on mount. 

    const changeTrackerRef = useRef(false); // To satisfy strict mode double invoke prevention if needed, but initiatedRef works.

    // Show streaming or just-completed content (before refresh)
    if (isJobForThisTopic && displayContent) {
        return (
            <div className={cn("space-y-6", isThisTopicGenerating && "animate-pulse-subtle")}>
                <article className="prose prose-stone dark:prose-invert max-w-none prose-lg prose-p:leading-relaxed">
                    <ReactMarkdown components={{ a: WikiLink as any }}>{displayContent}</ReactMarkdown>
                    {isThisTopicGenerating && (
                        <span className="inline-block w-2 h-4 bg-primary animate-pulse ml-1 align-middle" />
                    )}
                </article>
            </div>
        );
    }

    if (!initialContent || initialContent === "Autogenerated stub.") {
        // If we simply haven't triggered yet (timer running), show loading
        // OR if we tried and it failed, show button.

        // Simple heuristic: If we define "attempted" as "timer finished calling startJob",
        // then if !hasAttemptedAuto, we show spinner.
        // If hasAttemptedAuto is true, but we are back here (not active), it means it failed or was cancelled.
        // So show button.

        return (
            <div className="flex flex-col items-center justify-center py-20 px-8 text-center border-2 border-dashed border-border rounded-xl bg-muted/20">
                <Sparkles className="w-12 h-12 text-primary mb-6 opacity-80" />
                <h3 className="text-xl font-serif font-bold mb-3">This Topic is empty</h3>
                <p className="text-muted-foreground max-w-md mb-8">
                    The knowledge base entry exists, but the content hasn't been written yet.
                </p>

                {!hasAttemptedAuto ? (
                    <div className="flex items-center gap-3 text-muted-foreground animate-pulse">
                        <Loader2 className="w-5 h-5 animate-spin" />
                        <span>Initializing AI Agent...</span>
                    </div>
                ) : (
                    // Fallback Button
                    <button
                        onClick={() => startJob({ topicId: topic.id, type: 'syllabus' })}
                        className="px-6 py-3 bg-primary text-primary-foreground rounded-full font-medium hover:scale-105 transition-transform shadow-lg shadow-primary/20 flex items-center gap-2"
                    >
                        <Sparkles className="w-4 h-4" /> Generate Article
                    </button>
                )}
            </div>
        );
    }

    return (
        <div className="mb-12">
            <h2 className="text-2xl font-serif mb-6 text-primary/80 italic">Overview</h2>
            <article className="prose prose-stone dark:prose-invert max-w-none prose-lg prose-p:leading-relaxed">
                <ReactMarkdown>{localContent}</ReactMarkdown>
            </article>
        </div>
    );
}
