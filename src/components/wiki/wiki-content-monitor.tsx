"use client";

import { useGenerationStore } from "@/lib/generation-store";
import { useEffect, useState } from "react";
import ReactMarkdown from "react-markdown"; // Verify if used?
import { WikiLink } from "./wiki-link";

import { Loader2, Sparkles } from "lucide-react";
import { cn } from "@/lib/utils";

interface WikiContentMonitorProps {
    topic: any;
    initialContent: string;
}

import { useRouter } from "next/navigation";

// ... inside component function ...
export function WikiContentMonitor({ topic, initialContent }: WikiContentMonitorProps) {
    const router = useRouter();
    const { activeJob, startJob, queue } = useGenerationStore();
    const [localContent, setLocalContent] = useState(initialContent);
    const [isGenerating, setIsGenerating] = useState(false);
    const [wasGenerating, setWasGenerating] = useState(false);

    // Is THIS topic currently being generated?
    const isThisTopicActive = activeJob?.topicId === topic.id;

    // Monitor active state to trigger refresh on completion
    useEffect(() => {
        if (isThisTopicActive) {
            setWasGenerating(true);
        } else if (wasGenerating) {
            // Job just finished
            setWasGenerating(false);
            console.log("Generation finished, refreshing page data...");
            router.refresh();
        }
    }, [isThisTopicActive, wasGenerating, router]);

    // Determine content to show:

    // Determine content to show:
    // If active and generating, use activeJob.content (streaming)
    // Else use initialContent (static)
    // Note: If job just finished, activeJob might be null or status=completed.
    // If we rely on 'initialContent', we need the page to refresh/revalidate to show the new DB content.
    // Since we don't have automatic revalidation here yet, we should probably check if we *were* just generating this topic.
    // However, simplest fix for streaming is direct access.

    // Fallback: If we have an active job for this topic, show that.
    // If not, show initialContent.
    const displayContent = (isThisTopicActive && activeJob?.content)
        ? activeJob.content
        : (localContent || initialContent);

    useEffect(() => {
        // Just sync initial if needed? No, purely derived.
    }, []);

    const handleAutoGenerate = () => {
        if (!isGenerating && (!initialContent || initialContent === "Autogenerated stub.")) {
            startJob({
                topicId: topic.id,
                type: 'syllabus',
            });
        }
    };

    // Auto-trigger if empty stub
    useEffect(() => {
        if (!initialContent || initialContent === "Autogenerated stub.") {
            // delay slightly to avoid hydration mismatch or flashing
            // handleAutoGenerate(); 
            // Better: Show a button to "Start Generation" to be user-initiated first?
            // User wants "persistent... continues in background".
            // Let's autoshow a button or loading state.
        }
    }, []);

    if (isThisTopicActive) {
        return (
            <div className="space-y-6 animate-pulse-subtle">

                <article className="prose prose-stone dark:prose-invert max-w-none prose-lg prose-p:leading-relaxed">
                    <ReactMarkdown components={{ a: WikiLink as any }}>{displayContent}</ReactMarkdown>
                    <span className="inline-block w-2 h-4 bg-primary animate-pulse ml-1 align-middle" />
                </article>
            </div>
        );
    }

    if (!initialContent || initialContent === "Autogenerated stub.") {
        return (
            <div className="flex flex-col items-center justify-center py-20 px-8 text-center border-2 border-dashed border-border rounded-xl bg-muted/20">
                <Sparkles className="w-12 h-12 text-primary mb-6 opacity-80" />
                <h3 className="text-xl font-serif font-bold mb-3">This Topic is empty</h3>
                <p className="text-muted-foreground max-w-md mb-8">
                    The knowledge base entry exists, but the content hasn't been written yet.
                    Initialize the AI generation to create a comprehensive guide.
                </p>
                <button
                    onClick={() => startJob({ topicId: topic.id, type: 'syllabus' })}
                    className="px-6 py-3 bg-primary text-primary-foreground rounded-full font-medium hover:scale-105 transition-transform shadow-lg shadow-primary/20 flex items-center gap-2"
                >
                    <Sparkles className="w-4 h-4" /> Generate Article
                </button>
            </div>
        );
    }

    return (
        <div className="mb-12">
            <h2 className="text-2xl font-serif mb-6 text-primary/80 italic">Overview</h2>
            <article className="prose prose-stone dark:prose-invert max-w-none prose-lg prose-p:leading-relaxed">
                <ReactMarkdown>{localContent}</ReactMarkdown>
            </article>
        </div>
    );
}
